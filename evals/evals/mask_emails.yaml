uuid: 8C297EA8-42B9-4237-9571-5C95A042E3BA
version: 1
metadata:
  name: Python Function to Mask Emails
  description: Creates a python function that uses regex to mask all emails.
  difficulty: 1  # 1-5
  tags:
    - python
    - regex
  source: Anaconda. The ideal_responses were generated by ChatGPT 4.0 Turbo.
test_sequence:
  - prompt: Create a python function called `mask_emails` that uses regex to mask all emails. For each email in the format of `x@y.z`, the local part (`x`) should be masked, but the domain (`@y.z`) should be retained. Use type hints and docstrings.
    ideal_response: |
      To create a Python function called `mask_emails` that uses regex to mask all emails in a given text, follow these steps:

      - Import the `re` module for regular expression operations.
      - Define the function `mask_emails` with type hints for the input and output.
      - Use a regular expression to find all occurrences of emails in the text.
      - Replace the local part of each email (before the '@') with an appropriate mask (like asterisks '*').
      - Return the modified text with masked emails.

      Here's how the function might look:

      ```python
      import re

      def mask_emails(text: str) -> str:
          """
          Masks the local part of all email addresses found in the given text.

          Args:
          text (str): A string containing email addresses.

          Returns:
          str: The text with email local parts masked.

          Example:
          >>> mask_emails("Contact us at example@test.com")
          'Contact us at *******@test.com'
          """
          return re.sub(r'(\b[A-Za-z0-9._%+-]+)@', r'*******@', text)
      ```

      This function uses a regular expression to identify email addresses in the input text. The `\b[A-Za-z0-9._%+-]+` part matches the local part of the email address, and the `@` ensures that the match occurs right before the domain part. The `re.sub` function replaces the local part with asterisks. You can adjust the number of asterisks or the replacement character as needed.
    checks:
      - check_type: CONTAINS
        value: def mask_emails(
      - check_type: CONTAINS
        value: re.sub(
      - check_type: REGEX
        pattern: "def mask_email\\(\\s*[a-zA-Z_][a-zA-Z0-9_]*\\s*(\\s*:\\s*[a-zA-Z_][a-zA-Z0-9_]*\\s*)?\\)\\s*:"
      - check_type: PYTHON_CODE_BLOCKS_PRESENT
  - prompt: Create a set of assertion statements that test the function.
    ideal_response: |
      To thoroughly test the mask_emails function, you should create a series of assertion statements that cover various scenarios, including normal cases, edge cases, and potentially unexpected inputs. Here's a set of assertions you can use:

      ```python
      # Assuming the mask_emails function is defined as previously provided
      # Test with a standard email
      assert mask_emails("Contact me at john.doe@example.com for more information.") == "Contact me at *******@example.com for more information.", "Failed on standard email"
      # Test with multiple emails in the text
      assert mask_emails("Emails are alice@example.com and bob@example.com") == "Emails are *******@example.com and *******@example.com", "Failed on multiple emails"
      # Test with mixed case email
      assert mask_emails("Mixed case email: John.Doe@Example.COM") == "Mixed case email: *******@Example.COM", "Failed on mixed case email"
      # Test with email that has subdomains
      assert mask_emails("Subdomain email: user@sub.domain.com") == "Subdomain email: *******@sub.domain.com", "Failed on subdomain email"
      # Test with no emails in the text
      assert mask_emails("This is a test sentence with no emails.") == "This is a test sentence with no emails.", "Failed on no email"
      # Test with special characters in local part
      assert mask_emails("Special chars email: user+1234@example.com") == "Special chars email: *******@example.com", "Failed on special characters"
      # Test with numeric email
      assert mask_emails("Numeric email: 1234567890@numbers.com") == "Numeric email: *******@numbers.com", "Failed on numeric email"
      # Test with email in the beginning of the text
      assert mask_emails("user@example.com is my email") == "*******@example.com is my email", "Failed on email at beginning"
      # Test with email at the end of the text
      assert mask_emails("My email is user@example.com") == "My email is *******@example.com", "Failed on email at end"
      # Test with an empty string
      assert mask_emails("") == "", "Failed on empty string"
      print("All tests passed!")
      ```

      These tests cover a variety of common scenarios and edge cases, ensuring that the function behaves as expected in different situations. If all assertions pass without raising an AssertionError, it indicates that the function is working correctly for these test cases.
    checks:
      - check_type: CONTAINS
        value: assert mask_emails(
      - check_type: PYTHON_CODE_BLOCKS_PRESENT
      - check_type: PYTHON_CODE_BLOCKS_RUN
        code_setup: |
          import re
        functions:
          - |
            def verify_mask_emails_with_no_email_returns_original_string(code_blocks: list[str]) -> bool:
                value = 'This is a string with no email addresses'
                return mask_emails(value) == value
          - |
            def verify_mask_emails_with_single_email_returns_masked_string(code_blocks: list[str]) -> bool:
                value = 'This is a string with an email Susie@McSusers.com.'
                return mask_emails(value) == 'This is a string with an email [EMAIL].'
