metadata:
  uuid: 8C297EA8-42B9-4237-9571-5C95A042E3BA
  version: 1
  name: Python Function to Mask Emails
  description: Creates a python function that uses regex to mask all emails.
  difficulty: 1  # 1-5
  tags:
    - python
    - regex
  source: Anaconda. The ideal_responses were generated by ChatGPT 4.0 Turbo.
test_sequence:
  - prompt: Create a python function called `mask_emails` that uses regex to mask all emails. For each email in the format of `x@y.z`, the local part (`x`) should be masked with [MASKED], but the domain (`@y.z`) should be retained. Use type hints and docstrings.
    ideal_response: |
      Certainly! Below is a Python function named `mask_emails` which uses regular expressions (regex) to mask all email addresses in a given string. It replaces the local part of each email with `[MASKED]`, while retaining the domain.

      ```python
      import re
      from typing import AnyStr

      def mask_emails(text: AnyStr) -> AnyStr:
          """
          Masks all email addresses in the provided text. The local part of each email is replaced with [MASKED],
          while the domain is retained.

          Args:
          text (AnyStr): The string containing email addresses to be masked.

          Returns:
          AnyStr: The text with email addresses masked.
          """
          # Regular expression to match email addresses
          email_regex = r'[\w\.-]+@[\w\.-]+\.\w+'
          
          # Function to replace the local part of the email with [MASKED]
          def mask_email(match: re.Match) -> str:
              email = match.group(0)
              local, domain = email.split('@', 1)
              return f'[MASKED]@{domain}'

          # Replace all occurrences of email addresses in the text
          return re.sub(email_regex, mask_email, text)

      # Example usage
      text_with_emails = "Contact us at hello@example.com or support@domain.org for more information."
      masked_text = mask_emails(text_with_emails)
      print(masked_text)
      ```

      This function will take a string as input, search for all patterns that match the regex for an email address, and mask each email's local part while keeping the domain part unchanged. The `mask_email` function is a helper function used within `re.sub` to replace each found email address.

      The example usage at the end demonstrates how the function can be used on a sample text containing email addresses.
    checks:
      - check_type: CONTAINS
        value: re.sub(
      - check_type: REGEX
        pattern: "def mask_emails\\([a-zA-Z_]+\\: str\\) -> str\\:"
      - check_type: PYTHON_CODE_BLOCKS_PRESENT
  - prompt: Create a set of assertion statements that test the function.
    ideal_response: |
      To test the `mask_emails` function thoroughly, we can create a set of assertion statements. These assertions will check various scenarios including normal cases, edge cases, and potential failure points. Here's a set of assertions to cover a comprehensive range of test cases:

      ```python
      # Test with a standard email
      assert mask_emails("user@example.com") == "[MASKED]@example.com", "Failed to mask standard email"
      # Test with multiple emails in a string
      assert mask_emails("Emails: user1@example.com, user2@test.org") == "Emails: [MASKED]@example.com, [MASKED]@test.org", "Failed to mask multiple emails"
      # Test with emails having different domain lengths
      assert mask_emails("user@domain.co.uk") == "[MASKED]@domain.co.uk", "Failed to mask email with different domain lengths"
      # Test with emails having subdomains
      assert mask_emails("user@sub.domain.com") == "[MASKED]@sub.domain.com", "Failed to mask email with subdomains"
      # Test with emails having numeric, hyphen, and underscore characters
      assert mask_emails("user-name_123@example.com") == "[MASKED]@example.com", "Failed to mask email with numeric, hyphen, and underscore characters"
      # Test with no emails in the string
      assert mask_emails("No emails here") == "No emails here", "Failed when no emails are present"
      # Test with an empty string
      assert mask_emails("") == "", "Failed on empty string"
      # Test with a string containing multiple types of emails
      assert mask_emails("Emails: user@example.com, another_user@test.co, yet.another-user@subdomain.domain.net") == "Emails: [MASKED]@example.com, [MASKED]@test.co, [MASKED]@subdomain.domain.net", "Failed to mask multiple types of emails"
      # Print a success message if all assertions pass
      print("All tests passed successfully.")
      ```

      Each assertion checks a different aspect of the email masking function:

          Handling of standard email formats.
          Correct processing of multiple emails in a single string.
          Ability to handle emails with various domain lengths and structures, including subdomains.
          Correct handling of emails with numeric, hyphen, underscore, and other allowed characters in the local part.
          Proper behavior when no emails are present in the input string.
          Handling of an empty string as input.
          Masking emails with special characters in the local part.
          Dealing with a mix of different types of email formats in a single string.

      If any of these assertions fail, it will raise an `AssertionError` with a message indicating which test case failed. If all assertions pass, it prints a success message. This set of tests ensures that the `mask_emails` function behaves as expected in a variety of scenarios.
    checks:
      - check_type: CONTAINS
        value: assert mask_emails(
      - check_type: PYTHON_CODE_BLOCKS_PRESENT
      - check_type: PYTHON_CODE_BLOCKS_RUN
        code_setup: |
          import re
        code_tests:
          - |
            def verify_mask_emails_with_no_email_returns_original_string(code_blocks: list[str]) -> bool:
                value = 'This is a string with no email addresses'
                return mask_emails(value) == value
          - |
            def verify_mask_emails_with_single_email_returns_masked_string(code_blocks: list[str]) -> bool:
                value = 'This is a string with an email Susie@McSusers.com.'
                return mask_emails(value) == 'This is a string with an email [MASKED]@McSusers.com.'
